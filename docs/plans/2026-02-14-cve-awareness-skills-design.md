# CVE Awareness Skills Design

## Problem

When working on code — debugging, developing features, running RCA — Claude Code
may encounter or introduce dependencies with known CVEs. Without a structured gate,
CVE details can accidentally leak into public GitHub PRs, issues, comments, or
commit messages before responsible disclosure occurs.

**Accidental public CVE disclosure can enable exploitation before patches exist,
violate responsible disclosure agreements, and cause legal and reputational harm.**

## Goals

1. **Detect** CVEs in project dependencies during development workflows
2. **Block** all public output (PRs, issues, comments, commit messages) that could
   expose undisclosed CVE details
3. **Guide** responsible disclosure through proper channels per affected project
4. **Enable** silent fixes (dependency bumps, patches) that don't reference the CVE
5. **Integrate** into existing TDD, RCA, and publishing flows as mandatory gates

## Architecture

### Skill Structure

```
.claude/skills/
├── cve/SKILL.md                # Parent router
├── cve:scan/SKILL.md           # Hybrid scanning (Trivy + LLM + WebSearch)
└── cve:brainstorm/SKILL.md     # Disclosure planning & public output gate
```

**`cve` (parent router):** Routes to `cve:scan` for detection or `cve:brainstorm`
for response based on context.

**`cve:scan`:** Hybrid detection engine combining Trivy CLI, LLM knowledge, and
web searches against NVD/OSV/GitHub Advisory Database.

**`cve:brainstorm`:** Disclosure planning, silent fix guidance, and hard blocking
gate for all public GitHub actions.

## cve:scan — Detection Flow

### Phase 1: Inventory

Identify all dependency sources in the working tree:

| Ecosystem | Files |
|-----------|-------|
| Python | `pyproject.toml`, `requirements*.txt`, `uv.lock` |
| Node | `package.json`, `package-lock.json` |
| Go | `go.mod`, `go.sum` |
| Containers | `Dockerfile`, `Containerfile` |
| Helm | `Chart.yaml`, `values.yaml` (image references) |
| System | Vendored binaries or compiled artifacts |

### Phase 2: Trivy Scan (if available)

```bash
which trivy
trivy fs --severity HIGH,CRITICAL --format json .
trivy image --severity HIGH,CRITICAL --format json <image>
```

If Trivy is not installed, skip to Phase 3 with a note.

### Phase 3: LLM + WebSearch Analysis

For each dependency + version found in Phase 1:
- Check LLM training data for known CVEs
- WebSearch against NVD, OSV, GitHub Advisory Database
- Focus on HIGH and CRITICAL severity
- Cross-reference Trivy findings with web results

### Phase 4: Findings Report

- Written to `/tmp/kagenti/cve/scan-<timestamp>.json` (local only)
- Contains: package, version, CVE ID, severity, affected versions, fixed version,
  source URL
- **NEVER** written to git, committed, or included in any public output
- Summary displayed to user in terminal only

### Output Classification

| Finding | Action |
|---------|--------|
| No CVEs found | Green light — proceed with workflow |
| Known CVE with fix available | Invoke `cve:brainstorm` — can likely bump dependency silently |
| Known CVE without fix | Invoke `cve:brainstorm` — needs disclosure planning |
| Suspected but unconfirmed | Flag for user review, don't block |

## cve:brainstorm — Disclosure & Response Flow

### Phase 1: Disclosure Channel Discovery

For each affected dependency:
1. WebSearch for the project's SECURITY.md or responsible disclosure policy
2. Check the project's GitHub repo for `SECURITY.md` via `gh api`
3. Present to user: disclosure channel, security email/form, embargo expectations

### Phase 2: Fix Assessment

Interactive brainstorm with user (one question at a time):

1. **Is a fixed version available?** → Can we bump the dependency?
2. **Can the fix be applied silently?** Without exposing CVE details:
   - Dependency bump → message: "Bump `<pkg>` to `<ver>`" (no CVE reference)
   - Config change → message describes config, not vulnerability
   - Code workaround → message describes behavior, not security issue
3. **Does the fix change behavior?** → Test descriptions must not reference CVE

### Phase 3: Public Output Blocking (HARD GATE)

When a CVE hold is active, the following actions are **BLOCKED**:

| Action | Blocked? | Reason |
|--------|----------|--------|
| `gh pr create` | YES | PR description could leak CVE details |
| `gh pr comment` | YES | Comment could reference vulnerability |
| `gh issue create` | YES | Issue could describe vulnerability publicly |
| `gh issue comment` | YES | Same as above |
| Commit messages with CVE IDs | YES | `git log` is public |
| Code review responses | YES | Review comments are public |
| Writing CVE refs to git-tracked `.md` | YES | Content scanned before write |

The following actions remain **ALLOWED**:

| Action | Allowed? | Reason |
|--------|----------|--------|
| Local code changes | YES | Not public |
| Local testing | YES | Not public |
| Private notes to `/tmp/` | YES | Not public |
| Dependency bumps (clean message) | YES | Silent fix |
| `git commit` with clean message | YES | No CVE exposure |
| `git push` of clean commits | YES | No CVE exposure |

### Phase 4: Resolution

Hold is resolved when user confirms one of:
- "CVE reported to `<channel>`" → hold lifted
- "CVE fixed silently, bumped to `<version>`" → hold lifted
- "False positive, not a real CVE" → hold lifted
- "CVE hold resolved" (explicit user override) → hold lifted with warning

## Integration Points

### tdd:ci — Phase 3.5 (after Local Checks, before Push)

```
Phase 3.5: CVE Scan
  Invoke cve:scan on the working tree.
  If findings → invoke cve:brainstorm. Do NOT proceed to Phase 4 until resolved.
  If clean → proceed to Phase 4.
```

### tdd:hypershift / tdd:kind — Pre-deployment

```
Pre-deploy: CVE Scan
  Invoke cve:scan. Container images may contain vulnerable dependencies.
  If findings → invoke cve:brainstorm before deploying.
```

### rca:ci / rca:hypershift / rca:kind — Phase 5 addendum

```
Phase 5 addendum: CVE Check
  If root cause involves a dependency bug/behavior:
    Invoke cve:scan to check if this is a known CVE.
    If yes → invoke cve:brainstorm BEFORE documenting findings publicly.
```

### finishing-a-development-branch — Step 2.5

```
Step 2.5: CVE Gate
  Invoke cve:scan on the branch diff (changed/added dependencies).
  If findings → invoke cve:brainstorm. Block "Push and Create PR" until resolved.
```

### git:commit — Pre-commit check

```
Before committing:
  Scan commit message and staged files for CVE IDs (CVE-YYYY-NNNNN pattern).
  If found → WARN and require neutral description.
```

### PR creation — Pre-create gate

```
Before creating PR:
  1. Invoke cve:scan if not run in this session
  2. Scan PR title and body for CVE references
  3. Block if either scan finds issues
```

### Integration Summary

```
tdd:ci:           Phase 3 → [CVE GATE] → Phase 4
tdd:hypershift:   Pre-deploy → [CVE GATE] → Deploy
tdd:kind:         Pre-deploy → [CVE GATE] → Deploy
rca:*:            Phase 5 → [CVE CHECK] → Document
finishing-branch:  Step 2 → [CVE GATE] → Step 3
git:commit:       Pre-commit → [CVE ID CHECK] → Commit
PR creation:      Pre-create → [CVE GATE] → Create
```

## Design Decisions

1. **Hybrid scanning** — Trivy when available, LLM + WebSearch always. Best
   coverage without hard tool dependency.
2. **Web search per project** — Always look up the specific project's disclosure
   policy rather than maintaining a hardcoded mapping.
3. **Block all public GitHub actions** — Most conservative approach. PRs, issues,
   comments, and CVE-referencing commits are all blocked.
4. **Auto-inject into existing flows** — CVE gates are mandatory at integration
   points, not optional manual invocations.
5. **Local-only findings** — CVE scan results go to `/tmp/`, never to git.
6. **`repo:commit` removed** — Only `git:commit` used for commit conventions.

# Approach C: Envoy Sidecar + Correlation ID + Post-hoc Reconstruction

**Issue:** #667
**Goal:** Zero agent instrumentation using Envoy sidecars for span creation and correlation IDs for trace reconstruction.

## Overview

This approach, inspired by team discussion, uses Envoy sidecars to create spans at the infrastructure level and shared correlation IDs to reconstruct the full delegation chain post-hoc. Agents need zero instrumentation code.

> "Instead of trying to maintain a single trace tree across services, I gave up on parent-child refs entirely and used a shared correlation ID propagated as a header (x-request-id). Each proxy/sidecar creates its own independent spans, but they all carry that same ID. Then I reconstruct the causal chain after the fact using temporal backtracking."

## Architecture

```
┌─────────────────────────────────────────────┐
│ Agent Pod                                    │
│                                              │
│  ┌──────────┐                               │
│  │ Envoy    │ Creates spans for:            │
│  │ Sidecar  │ - Inbound request             │
│  │          │ - Outbound LLM calls          │
│  │          │ - Outbound tool calls         │
│  │          │                               │
│  │ Tags all spans with:                     │
│  │ - x-request-id (correlation)             │
│  │ - x-caller-id (who initiated)            │
│  │ - x-target (destination)                 │
│  │ - x-hop-kind (type of call)             │
│  └────┬─────┘                               │
│       │                                      │
│  ┌────▼─────────────────────────────────────┐│
│  │ Agent Code (NO changes)                  ││
│  │ - Just propagates x-request-id header    ││
│  │ - No OTEL SDK needed                     ││
│  └──────────────────────────────────────────┘│
└──────────────────────────────────────────────┘
         │
         ▼
┌────────────────────────────────┐
│ OTEL Collector                 │
│                                │
│ Independent spans per hop:     │
│ [inbound] x-req-id=abc123     │
│ [llm-call] x-req-id=abc123    │
│ [tool-call] x-req-id=abc123   │
│                                │
│ All tagged with same           │
│ correlation ID                 │
└──────────────┬─────────────────┘
               │
               ▼
┌────────────────────────────────┐
│ Post-hoc Trace Reconstruction  │
│                                │
│ Temporal backtracking:         │
│ For each span, find most       │
│ recent inbound span whose      │
│ target matches current actor   │
│ before current timestamp       │
│                                │
│ Reconstructs:                  │
│ Client → Agent → LLM          │
│        └→ Agent → Tool         │
└────────────────────────────────┘
```

## How It Works

### 1. Envoy Sidecar Spans (Infrastructure-Level)

Envoy natively creates tracing spans for every proxied request. With Istio Ambient or standalone Envoy sidecars, this gives us:

- **Inbound span**: Client → Agent (captures request method, path, status)
- **Outbound spans**: Agent → LLM provider, Agent → MCP tool server

### 2. Correlation via x-request-id

Every Envoy hop tags spans with `x-request-id` (auto-generated by first Envoy in the chain). This ID propagates through all downstream calls, creating a shared correlation key.

### 3. Trust Metadata Headers

Additional headers injected by sidecars:
- `x-caller-id`: Identity of the calling service (from SPIFFE SVID)
- `x-caller-type`: Type of caller (user, agent, tool)
- `x-target`: Destination service
- `x-hop-kind`: Type of call (agent-invoke, llm-call, tool-call)

### 4. Temporal Backtracking Reconstruction

Post-processing step that reconstructs the causal chain:
```
For each span S with correlation_id C:
  Find the most recent span S' where:
    S'.correlation_id == C
    S'.target == S.caller_id
    S'.timestamp < S.timestamp
  Set S.parent = S'
```

## Critical Assessment: MLflow Compatibility

### Why This Won't Pass MLflow E2E Tests

**MLflow requires real parent-child trace trees**, not post-hoc correlation:

1. **Root span attributes**: MLflow reads `mlflow.spanInputs`/`mlflow.spanOutputs` from the root span. Envoy spans don't have access to request/response body content - they only see HTTP metadata (method, path, status code, headers).

2. **Trace hierarchy**: MLflow expects a single trace with nested spans (root → LangChain → LLM). Post-hoc reconstruction produces separate traces that need custom backend processing to merge.

3. **GenAI attributes**: Envoy spans won't have `gen_ai.agent.name`, `gen_ai.conversation.id`, etc. These require parsing A2A JSON-RPC bodies, which Envoy's native tracing cannot do.

4. **Token usage**: LLM token counts come from auto-instrumentation inside the agent. Without agent-side OTEL SDK, these metrics are not captured.

### What This Approach IS Good For

- **Delegation chain visibility**: Who called whom, in what order
- **Trust boundary enforcement**: Validating that delegation paths match expected patterns
- **Anomaly detection**: Flagging unexpected service-to-service calls
- **Cost attribution by service**: HTTP-level metrics (request count, latency, bytes)

## Comparison Table

| Requirement | This Approach | Approach A (AuthBridge) | Approach B (Minimal Agent) |
|------------|---------------|------------------------|---------------------------|
| Agent code changes | None | None | ~50 lines |
| Root span with body content | No | Yes | Yes |
| MLflow attributes | No | Yes | Yes (via collector) |
| GenAI attributes | No | Yes | Yes |
| Token usage (LLM) | No | Yes (auto-instr) | Yes (auto-instr) |
| Delegation chain | Yes | Partial | No |
| Trust verification | Yes | Partial | No |
| MLflow E2E tests | FAIL | PASS | MOSTLY PASS |

## Recommendation

**This approach should NOT be pursued as a standalone solution for MLflow/Phoenix observability.** It is fundamentally designed for a different use case (delegation provenance) and cannot satisfy the body-parsing requirements of GenAI observability.

However, it is **complementary** to Approach A or B:
- **Approach A + C**: AuthBridge creates GenAI root spans + Envoy sidecars track delegation chains
- **Approach B + C**: Agent creates minimal root spans + Envoy sidecars track delegation chains

The delegation/provenance layer and the GenAI observability layer serve different purposes and can share infrastructure (same sidecars, same collector pipeline, same propagation headers).

## What This Worktree Will Contain

Since this approach cannot pass MLflow E2E tests alone, this worktree will:
1. Document the approach and its limitations clearly
2. Show how it complements Approaches A and B
3. Include a proof-of-concept Envoy config with tracing enabled
4. NOT attempt to pass MLflow E2E tests
